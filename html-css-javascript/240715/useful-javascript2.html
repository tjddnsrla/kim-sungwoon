<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 비구조화 할당시 기본값 설정
        const object = { a: 1 };
        const { a, b = 3 } = object;

        function print({ a, b = 2 }) {
            console.log(a);
            console.log(b);
        }
        print(object);  // 1, 3

        // 비구조화 할당시 이름 바꾸기
        const animal = {
            name: '멍멍이',
            type: '개'
        };

        const { name: nickname } = animal;  // name을 nickname으로 바꿈
        console.log(nickname);

        // 배열 비구조화 할당
        const array = [1, 2];
        const [one, two = 3] = array;

        console.log(one);
        console.log(two);

        // 깊은 값 비구조화 할당
        const deepObject = {
            state: {
                information: {
                    name: 'velopert',
                    languages: ['korean', 'english', 'chinese']
                }
            },
            value: 5,
        };
        const { name, languages } = deepObject.state.information;
        const { value } = deepObject;
        const extracted = {
            name,
            languages,
            value
        };
        console.log(extracted); // {name: "velopert", languages: Array[3], value: 5}

        const { name1, languages1 } = deepObject;   // error
        console(x, y);  // error
        console(name1, languages1);     // error

        // spread연산자 사용(객체)
        const slime = {
            name: '슬라임'
        };

        const cuteSlime = {
            ...slime,       // ...은 spread연산자
            attribute: 'cute'
        };
        const cuteSlime2 = {
            slime,
            attribute: 'cute'
        };

        const purpleCuteSlime = {
            ...cuteSlime,   // ...은 spread연산자
            color: 'purple'
        };

        console.log(slime); // {name: "슬라임"}
        console.log(cuteSlime); // {name: "슬라임", attribute: "cute"}
        console.log(cuteSlime2); // {slime: {name: "슬라임"}, attribute: "cute"}
        console.log(purpleCuteSlime); // {name: "슬라임", attribute: "cute", color: "purple"}

        // spread연산자 사용(배열)
        const animals = ['개', '고양이', '참새'];
        // for (let i = 0; animals.length; i++) {
        //     anotherAnimals.push(animals[i])
        // }
        // anotherAnimals.push('비둘기');
        const anotherAnimals = [...animals, '비둘기'];
        const anotherAnimals2 = [animals, '비둘기'];
        console.log(animals); // ["개", "고양이", "참새"]
        console.log(anotherAnimals); // ["개", "고양이", "참새", "비둘기"]
        console.log(anotherAnimals2); // [["개", "고양이", "참새"], "비둘기"]

        // 배열에서 spread 연산자를 여러번 사용
        const numbers = [1, 2, 3, 4, 5];

        const spreadNumbers = [...numbers, 1000, ...numbers];
        console.log(spreadNumbers); // [1, 2, 3, 4, 5, 1000, 1, 2, 3, 4, 5]

        // 객체에서의 ...(rest연산자)
        // const purpleCuteSlime = {
        //     name: '슬라임',
        //     attribute: 'cute',
        //     color: 'purple'
        // };

        const { color, ...abc } = purpleCuteSlime;
        console.log(color); // purple
        console.log(abc);  // {name: "슬라임", attribute: "cute"}

        const { attribute, ...abc2 } = cuteSlime;
        console.log(attribute); // cute
        console.log(abc2);  // {name: "슬라임"}

        const numbers2 = [0, 1, 2, 3, 4, 5, 6];
        const [one2, ...rest] = numbers2; // rest연산자는 뒤에서만 가능

        console.log(one2);
        console.log(rest);

        function sum(...rest) {
            return rest.reduce((acc, current) => acc + current, 0);
        }
        console.log(sum(1,2,3,4));  // [1, 2, 3, 4]

        1 + 1
        '1' + '1'
    </script>
</body>
</html>